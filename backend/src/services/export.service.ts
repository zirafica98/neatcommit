/**
 * Export Service
 * 
 * Servis za export podataka u razliƒçite formate (PDF, CSV, Excel)
 */

// Import packages directly
import PDFDocument from 'pdfkit';
import * as XLSX from 'xlsx';
import { Review, Issue } from '@prisma/client';
import { logger } from '../utils/logger';

export class ExportService {
  /**
   * Export review u PDF format
   */
  static async exportReviewToPDF(review: Review & { issues?: Issue[]; repository?: any }): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({ margin: 50 });
        const buffers: Buffer[] = [];

        doc.on('data', buffers.push.bind(buffers));
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(buffers);
          resolve(pdfBuffer);
        });
        doc.on('error', reject);

        // Set default font (PDFKit requires a font)
        doc.font('Helvetica');
        
        // Header
        doc.fontSize(20).text('Code Review Report', { align: 'center' });
        doc.moveDown();

        // Review Information
        doc.fontSize(14).text('Review Information', { underline: true });
        doc.fontSize(12);
        doc.text(`PR Title: ${review.githubPrTitle || 'N/A'}`);
        doc.text(`Repository: ${review.repository?.fullName || 'N/A'}`);
        doc.text(`Security Score: ${review.securityScore || 0}/100`);
        doc.text(`Status: ${review.status}`);
        doc.text(`Created: ${review.createdAt.toLocaleString()}`);
        doc.moveDown();

        // Summary - removed as Review model doesn't have summary field

        // Issues
        if (review.issues && review.issues.length > 0) {
          doc.fontSize(14).text('Issues Found', { underline: true });
          doc.moveDown(0.5);

          review.issues.forEach((issue, index) => {
            doc.fontSize(12).text(`${index + 1}. ${issue.title}`, { continued: false });
            doc.fontSize(10).text(`   Severity: ${issue.severity} | Category: ${issue.category}`, {
              indent: 20,
            });
            if (issue.description) {
              doc.text(`   ${issue.description}`, { indent: 20 });
            }
            if (issue.filePath) {
              doc.text(`   File: ${issue.filePath}`, { indent: 20 });
            }
            doc.moveDown(0.5);
          });
        }

        // Footer
        doc.fontSize(10).text(
          `Generated by NeatCommit on ${new Date().toLocaleString()}`,
          { align: 'center' }
        );

        doc.end();
      } catch (error) {
        logger.error('PDF export error:', error);
        reject(error);
      }
    });
  }

  /**
   * Export issues u CSV format
   */
  static exportIssuesToCSV(issues: Issue[]): string {
    const headers = ['Title', 'Severity', 'Category', 'Description', 'File Path', 'Line Number', 'Created At'];
    const rows = issues.map((issue) => [
      issue.title,
      issue.severity,
      issue.category,
      issue.description || '',
      issue.filePath || '',
      issue.line?.toString() || '',
      issue.createdAt.toISOString(),
    ]);

    const csvContent = [headers, ...rows]
      .map((row) => row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    return csvContent;
  }

  /**
   * Export statistika u Excel format
   */
  static exportStatsToExcel(stats: {
    totalReviews: number;
    totalIssues: number;
    criticalIssues: number;
    highIssues: number;
    mediumIssues: number;
    lowIssues: number;
    averageScore: number;
    reviewsByStatus?: any[];
    issuesByCategory?: any[];
  }): Buffer {
    logger.info('Generating Excel file', {
      totalReviews: stats.totalReviews,
      totalIssues: stats.totalIssues,
      averageScore: stats.averageScore,
    });

    const workbook = XLSX.utils.book_new();

    // Summary Sheet - use object format for better compatibility
    const summaryData = [
      { Metric: 'Total Reviews', Value: stats.totalReviews },
      { Metric: 'Total Issues', Value: stats.totalIssues },
      { Metric: 'Critical Issues', Value: stats.criticalIssues },
      { Metric: 'High Issues', Value: stats.highIssues },
      { Metric: 'Medium Issues', Value: stats.mediumIssues },
      { Metric: 'Low Issues', Value: stats.lowIssues },
      { Metric: 'Average Security Score', Value: stats.averageScore },
    ];
    
    logger.info('Summary data before sheet creation', { 
      data: summaryData,
      firstRow: summaryData[0],
    });
    
    const summarySheet = XLSX.utils.json_to_sheet(summaryData);
    
    // Set column widths for better readability
    summarySheet['!cols'] = [
      { wch: 25 }, // Metric column
      { wch: 15 }, // Value column
    ];
    
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
    
    logger.info('Summary sheet created', { 
      rowCount: summaryData.length,
      sheetRange: summarySheet['!ref'],
      firstCell: summarySheet['A1'],
      secondCell: summarySheet['B1'],
    });

    // Reviews by Status Sheet (always add, even if empty)
    if (stats.reviewsByStatus && stats.reviewsByStatus.length > 0) {
      const reviewsData = stats.reviewsByStatus.map((item) => ({
        Status: item.status,
        Count: item.count,
      }));
      const reviewsSheet = XLSX.utils.json_to_sheet(reviewsData);
      reviewsSheet['!cols'] = [{ wch: 20 }, { wch: 10 }];
      XLSX.utils.book_append_sheet(workbook, reviewsSheet, 'Reviews by Status');
    } else {
      // Add empty sheet with headers
      const emptyReviewsSheet = XLSX.utils.json_to_sheet([{ Status: 'No data', Count: 0 }]);
      emptyReviewsSheet['!cols'] = [{ wch: 20 }, { wch: 10 }];
      XLSX.utils.book_append_sheet(workbook, emptyReviewsSheet, 'Reviews by Status');
    }

    // Issues by Category Sheet (always add, even if empty)
    if (stats.issuesByCategory && stats.issuesByCategory.length > 0) {
      const issuesData = stats.issuesByCategory.map((item) => ({
        Category: item.category,
        Count: item.count,
      }));
      const issuesSheet = XLSX.utils.json_to_sheet(issuesData);
      issuesSheet['!cols'] = [{ wch: 20 }, { wch: 10 }];
      XLSX.utils.book_append_sheet(workbook, issuesSheet, 'Issues by Category');
    } else {
      // Add empty sheet with headers
      const emptyIssuesSheet = XLSX.utils.json_to_sheet([{ Category: 'No data', Count: 0 }]);
      emptyIssuesSheet['!cols'] = [{ wch: 20 }, { wch: 10 }];
      XLSX.utils.book_append_sheet(workbook, emptyIssuesSheet, 'Issues by Category');
    }

    logger.info('Writing Excel workbook', { 
      sheetCount: workbook.SheetNames?.length || 0,
      sheetNames: workbook.SheetNames || [],
    });

    // Use writeFile with buffer option
    const excelBuffer = XLSX.write(workbook, { 
      type: 'buffer', 
      bookType: 'xlsx',
      compression: true,
    });
    
    if (!excelBuffer || excelBuffer.length === 0) {
      logger.error('XLSX write returned empty buffer');
      throw new Error('Failed to generate Excel file');
    }
    
    logger.info('Excel file generated successfully', { bufferSize: excelBuffer.length });
    
    return Buffer.from(excelBuffer);
  }
}
